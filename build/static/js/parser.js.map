{"version":3,"sources":["parser.js"],"names":["window","parser","tokenize","value","m","results","tokenRegEx","exec","push","peek","tokens","position","next","createToken","type","token","parsePrimary","result","operatorRegex","test","right","parseAdditive","numberRegex","left","cellRegex","processOperator","condition","expressionCallback","expression","parseMultiplicative","nextChar","c","String","fromCharCode","charCodeAt","cleanupSumMean","string","fname","counter","replace","expandSumAndMean","cells","startLetter","endLetter","startNum","endNum","createSeries","clause","increment","split","parseInt","console","log","setSpreadSheet","newSpreadSheet","spreadSheet","setSocket","newSocket","socket","init","expandCells","visitedCells","label","cell","getCellById","formula","cellRegex2","indexOf","visited","id","Array","prototype","apply","curry","match","length","args","slice","call","arguments","fn","shift","concat","parse","functionRegex"],"mappings":"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","file":"parser.js","sourcesContent":["window.parser = (function () {\n\tvar functionRegex = /(sum|avg|mean)\\(\\s*[a-z]([1-9]\\d+|[1-9])\\s*:\\s*[a-z]([1-9]\\d+|[1-9])\\s*\\)/ig;\n\tvar cellRegex = /^[A-Z]([1-9]\\d+|[1-9])$/i;\n\tvar cellRegex2 = /[A-Z]([1-9]\\d+|[1-9])/ig;\n\tvar operatorRegex = /[+\\-\\/\\*\\^]/;\n\tvar numberRegex = /^\\d+(\\.\\d+)?$/;\n\tvar position = 0;\n\tvar tokens = [];\n\tvar tokenRegEx = /([A-Z]([1-9]\\d+|[1-9])|\\d+(\\.\\d+)?|[+\\-\\/\\*\\^]|\\(|\\))/ig;\n\n\tfunction tokenize(value) {\n\t\tvar results = [];\n\t\tvar m;\n\n\t\twhile ((m = tokenRegEx.exec(value)) !== null) {\n\t\t\tresults.push(m[0]); //save token\n\t\t}\n\t\treturn results;\n\t}\n\n\tfunction peek() {\n\t\treturn tokens[position];\n\t}\n\n\tfunction next() {\n\t\tvar value = peek();\n\t\tposition++;\n\t\treturn value;\n\t}\n\n\tfunction createToken(value, type) {\n\t\tposition++;\n\t\treturn {\n\t\t\ttoken: value,\n\t\t\ttype: type\n\t\t};\n\t}\n\n\tfunction parsePrimary() {\n\t\tvar result = {};\n\t\tvar value = peek();\n\n\t\tif (operatorRegex.test(value)) {\n\t\t\tresult = createToken(value, 'unary');\n\t\t\tresult.right = parseAdditive();\n\t\t} else if (numberRegex.test(value)) {\n\t\t\tresult = createToken(value, 'number');\n\t\t} else if (/^\\($/.test(value)) {\n\t\t\tresult = createToken(value, 'leftparen');\n\t\t\tresult.left = parseAdditive();\n\t\t\tvalue = peek();\n\t\t\tif (value === ')') {\n\t\t\t\tresult.right = createToken(value, 'rightparen');\n\t\t\t}\n\t\t} else if (cellRegex.test(value)) {\n\t\t\tresult = createToken(value, 'cellname');\n\t\t} else {\n\t\t\tresult = createToken(value, '');\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tfunction processOperator(condition, expressionCallback) {\n\t\tvar expression = expressionCallback();\n\t\tvar token = peek();\n\n\t\twhile (condition(token)) {\n\t\t\ttoken = next();\n\t\t\texpression = {\n\t\t\t\ttoken: token,\n\t\t\t\ttype: 'operator',\n\t\t\t\tleft: expression,\n\t\t\t\tright: expressionCallback()\n\t\t\t};\n\t\t\ttoken = peek();\n\t\t}\n\t\treturn expression;\n\t}\n\n\tfunction parseMultiplicative() {\n\t\treturn processOperator(function (token) {\n\t\t\treturn token === '*' || token === '/' || token === '^';\n\t\t}, parsePrimary);\n\t}\n\n\tfunction parseAdditive() {\n\t\treturn processOperator(function (token) {\n\t\t\treturn token === '+' || token === '-';\n\t\t}, parseMultiplicative);\n\t}\n\n\tfunction nextChar(c) {\n\t\treturn String.fromCharCode(c.charCodeAt(0) + 1);\n\t}\n\n\tfunction cleanupSumMean(string, fname, counter) {\n\t\tstring = string.replace(/^\\+/, '');\n\t\tstring = '(' + string + ')';\n\t\tif (fname === 'mean') {\n\t\t\tstring = '(' + string + '/' + counter + ')';\n\t\t}\n\t\treturn string;\n\t}\n\n\t/*\n\t * expandSumAndMean\n\t *\n\t * This function expands sum and mean into a longform\n\t * equivalent. Example:\n\t *\n\t * mean(a1:a5) => (a1+a2+a3+a4+a5)/5\n\t *\n\t * param {String} text rep of function\n\t */\n\tfunction expandSumAndMean(value) {\n\t\tvar startLetter = '';\n\t\tvar endLetter = '';\n\t\tvar startNum = '';\n\t\tvar endNum = '';\n\t\tvar cells;\n\t\tvar counter = 0;\n\t\tvar string = '#ERROR';\n\t\tvar fname = /sum/i.test(value) ? 'sum' : 'mean';\n\t\tvar createSeries = function (clause, increment) {\n\t\t\tstring = '';\n\t\t\twhile (clause()) {\n\t\t\t\tstring += '+' + startLetter + startNum;\n\t\t\t\tincrement();\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\tstring = cleanupSumMean(string, fname, counter);\n\t\t};\n\n\t\tvalue = value.replace(/(sum|avg|mean|[\\(\\)]+)/ig, '')\n\t\t\t.replace(' ', '');\n\t\tcells = value.split(':');\n\t\tstartLetter = cells[0][0];\n\t\tendLetter = cells[1][0];\n\t\tstartNum = parseInt(cells[0][1]);\n\t\tendNum = parseInt(cells[1][1]);\n\n\t\tif (startLetter === endLetter) {\n\t\t\tif (endNum >= startNum) {\n\t\t\t\tcreateSeries(function () {\n\t\t\t\t\treturn startNum <= endNum;\n\t\t\t\t}, function () {\n\t\t\t\t\tstartNum++;\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (endLetter >= startLetter) {\n\t\t\tif (endNum === startNum) {\n\t\t\t\tcreateSeries(function () {\n\t\t\t\t\treturn startLetter <= endLetter;\n\t\t\t\t}, function () {\n\t\t\t\t\tstartLetter = nextChar(startLetter);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tconsole.log('>>>', string);\n\t\treturn string;\n\t}\n\n\tvar socket;\n\tvar spreadSheet;\n\n\tfunction setSpreadSheet(newSpreadSheet) {\n\t\tspreadSheet = newSpreadSheet || spreadSheet;\n\t}\n\n\tfunction setSocket(newSocket) {\n\t\tsocket = newSocket || socket;\n\t}\n\n\tfunction init(spreadSheet, socket) {\n\t\tsetSpreadSheet(spreadSheet);\n\t\tsetSocket(socket);\n\t}\n\n\t/*\n\t * expandCells\n\t *\n\t * Recursively removes transitive relationships. If this is not done\n\t * it results in glitches.\n\t *\n\t * Example:\n\t * A1 = 1\n\t * B1 = A1+1\n\t * C1 = B1 + A1\n\t *   -> A1 + 1 + A1\n\t *\n\t * Added code to check for circular dependencies.\n\t *\n\t * param {String} user input\n\t */\n\tfunction expandCells(visitedCells, label) {\n\t\tvar cell = spreadSheet.getCellById(label);\n\t\tvar formula = cell.formula;\n\n\t\tif (cellRegex2.test(formula)) {\n\t\t\tif (visitedCells.indexOf(label) < 0) {\n\t\t\t\tvar visited = [cell.id];\n\t\t\t\tArray.prototype.push.apply(visited, visitedCells);\n\t\t\t\tlabel = formula.replace(cellRegex2, curry(expandCells, visited));\n\t\t\t} else {\n\t\t\t\tconsole.log('#ERROR CYCULAR DEPENDENCY', label, visitedCells);\n\t\t\t\tlabel = '#ERROR CYCULAR DEPENDENCY';\n\t\t\t}\n\t\t}\n\n\t\t//if there is more than one term in label\n\t\t//use brackets to preserve arithmatic order\n\t\tvar match = label.match(tokenRegEx);\n\t\tlabel = match && match.length > 1 ? '(' + label + ')' : label;\n\n\t\treturn label;\n\t}\n\n\tfunction curry() {\n\t\tvar args = Array.prototype.slice.call(arguments),\n\t\t\tfn = args.shift();\n\t\treturn function () {\n\t\t\treturn fn.apply(fn, args.concat(Array.prototype.slice.call(arguments)));\n\t\t};\n\t}\n\n\tfunction parse(value, label) {\n\t\tvalue = value || '';\n\t\tposition = 0;\n\t\tvalue = value.replace(functionRegex, expandSumAndMean);\n\t\tvalue = value.replace(cellRegex2, curry(expandCells, [label]));\n\n\t\tif (/ERROR/ig.test(value)) {\n\t\t\tif (/CIRCULAR/ig.test(value)) {\n\t\t\t\tvalue = '#ERROR CYCULAR DEPENDENCY';\n\t\t\t} else {\n\t\t\t\tvalue = '#ERROR';\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.log('tokenize:', value);\n\t\t\ttokens = tokenize(value);\n\t\t\tvalue = parseAdditive();\n\t\t}\n\t\treturn value;\n\t}\n\n\treturn {\n\t\tinit: init,\n\t\tparse: parse,\n\t\tsetSocket: setSocket,\n\t\tsetSpreadSheet: setSpreadSheet\n\t};\n})();\n"],"sourceRoot":"/source/"}