{"version":3,"sources":["parser.js"],"names":["window","parser","tokenize","value","m","results","tokenRegEx","exec","push","peek","tokens","position","next","createToken","type","token","cleanupSumMean","string","fname","counter","replace","sumMean","cells","startLetter","endLetter","startNum","endNum","test","split","parseInt","console","log","parsePrimary","result","operatorRegex","right","parseAdditive","numberRegex","left","cellRegex","parseMultiplicative","expression","parse","functionRegex"],"mappings":"AAAA,YAAAA,QAAOC,OAAU,WAQhB,QAASC,GAASC,GAMjB,IALA,GAIIC,GAJAC,KACAC,EACH,2FAGuC,QAAhCF,EAAIE,EAAWC,KAAKJ,KAC3BE,EAAQG,KAAKJ,EAAE,GAEhB,OAAOC,GAGR,QAASI,KACR,GAAIN,GAAQO,EAAOC,EACnB,OAAOR,GAGR,QAASS,KACR,GAAIT,GAAQM,GAEZ,OADAE,KACOR,EAGR,QAASU,GAAYV,EAAOW,GAE3B,MADAH,MAECI,MAAOZ,EACPW,KAAMA,GAIR,QAASE,GAAeC,EAAQC,EAAOC,GAMtC,MALAF,GAASA,EAAOG,QAAQ,MAAO,IAC/BH,EAAS,IAAMA,EAAS,IACV,SAAVC,IACHD,EAAS,IAAMA,EAAS,IAAME,EAAU,KAElCF,EAaR,QAASI,GAAQlB,GAChB,GAIImB,GAJAC,EAAc,GACdC,EAAY,GACZC,EAAW,GACXC,EAAS,GAETP,EAAU,EACVF,EAAS,SACTC,EAAQ,OAAOS,KAAKxB,GAAS,MAAO,MAOxC,IALAA,EAAQA,EAAMiB,QAAQ,uBAAuB,IAAIA,QAAQ,IAAI,IAC7DE,EAAQnB,EAAMyB,MAAM,KACpBL,EAAcD,EAAM,GAAG,GACvBE,EAAYF,EAAM,GAAG,GAEjBC,IAAgBC,GAGnB,GAFAC,EAAWI,SAASP,EAAM,GAAG,IAC7BI,EAASG,SAASP,EAAM,GAAG,IACvBI,GAAUD,EAAU,CAGvB,IAFAR,EAAS,GACTE,EAAUM,EACJA,GAAYC,GACjBT,GAAU,IAAMM,EAAcE,EAC9BA,IACAN,GAEDF,GAASD,EAAeC,EAAQC,EAAOC,QAElC,IAAIK,GAAaD,IACvBE,EAAWH,EAAM,GAAG,GACpBI,EAASJ,EAAM,GAAG,GACdI,IAAWD,GAAU,CAExB,IADAR,EAAS,GACHM,GAAeC,GACpBP,GAAU,IAAMM,EAAcE,EAC9BF,IACAJ,GAEDF,GAASD,EAAeC,EAAQC,EAAOC,GAIzC,MADAW,SAAQC,IAAI,MAAMd,GACXA,EAGR,QAASe,KACR,GAAIC,MACA9B,EAAQM,GAgCZ,OA/BIyB,GAAcP,KAAKxB,IACtB8B,EAASpB,EAAYV,EAAO,SAC5B8B,EAAOE,MAAQC,KACLC,EAAYV,KAAKxB,GAC3B8B,EAASpB,EAAYV,EAAO,UAClB,OAAOwB,KAAKxB,IACtB8B,EAASpB,EAAYV,EAAO,aAC5B8B,EAAOK,KAAOF,IACdjC,EAAQM,IACM,MAAVN,IACH8B,EAAOE,MAAQtB,EAAYV,EAAO,gBAGnC8B,EADUM,EAAUZ,KAAKxB,GAChBU,EAAYV,EAAO,YAenBU,EAAYV,EAAO,IAGtB8B,EAGR,QAASO,KAIR,IAHA,GAAIC,GAAaT,IACbjB,EAAQN,IAEK,MAAVM,GAA2B,MAAVA,GACvBA,EAAQH,IACR6B,GACC1B,MAAOA,EACPD,KAAM,WACNwB,KAAMG,EACNN,MAAOH,KAERjB,EAAQN,GAET,OAAOgC,GAGR,QAASL,KAIR,IAHA,GAAIK,GAAaD,IACbzB,EAAQN,IAEK,MAAVM,GAA2B,MAAVA,GACvBA,EAAQH,IACR6B,GACC1B,MAAOA,EACPD,KAAM,WACNwB,KAAMG,EACNN,MAAOK,KAERzB,EAAQN,GAET,OAAOgC,GAGR,QAASC,GAAMvC,GAId,MAHAQ,GAAW,EACXR,EAAQA,EAAMiB,QAAQuB,EAAetB,GACrCX,EAASR,EAASC,GACXiC,IAjLR,GAAIO,GAAgB,oDAChBJ,EAAY,cACZL,EAAgB,YAChBG,EAAc,gBACd1B,EAAW,EACXD,IA+KJ,OAAOgC","file":"parser.js","sourcesContent":["window.parser = (function () {\n\tvar functionRegex = /(sum|avg|mean)\\(\\s*[a-z]\\d+\\s*:\\s*[a-z]\\d+\\s*\\)/ig;\n\tvar cellRegex = /^[A-Z]\\d+$/i;\n\tvar operatorRegex = /[+\\-\\/\\*]/;\n\tvar numberRegex = /^\\d+(\\.\\d+)?$/;\n\tvar position = 0;\n\tvar tokens = [];\n\n\tfunction tokenize(value) {\n\t\tvar results = [];\n\t\tvar tokenRegEx =\n\t\t\t/([A-Z]\\d+|\\d+(\\.\\d+)?|[+\\-\\/\\*]|\\(|\\)|(sum|avg|mean)\\(\\s*[a-z]\\d+\\s*:\\s*[a-z]\\d+\\s*\\))/ig;\n\n\t\tvar m;\n\t\twhile ((m = tokenRegEx.exec(value)) !== null) {\n\t\t\tresults.push(m[0]); //save token\n\t\t}\n\t\treturn results;\n\t}\n\n\tfunction peek() {\n\t\tvar value = tokens[position];\n\t\treturn value;\n\t}\n\n\tfunction next() {\n\t\tvar value = peek();\n\t\tposition++;\n\t\treturn value;\n\t}\n\n\tfunction createToken(value, type) {\n\t\tposition++;\n\t\treturn {\n\t\t\ttoken: value,\n\t\t\ttype: type\n\t\t};\n\t}\n\n\tfunction cleanupSumMean(string, fname, counter) {\n\t\tstring = string.replace(/^\\+/, '');\n\t\tstring = '(' + string + ')';\n\t\tif (fname === 'mean') {\n\t\t\tstring = '(' + string + '/' + counter + ')';\n\t\t}\n\t\treturn string;\n\t}\n\t\n\t/*\n   * sumMean\n   *\n   * This function expands sum and mean into a longform\n\t * equivalent. Example:\n\t *\n\t * mean(a1:a5) => (a1+a2+a3+a4+a5)/5\n   *\n   * param {String} text rep of function\n   */\n\tfunction sumMean(value) {\n\t\tvar startLetter = '';\n\t\tvar endLetter = '';\n\t\tvar startNum = '';\n\t\tvar endNum = '';\n\t\tvar cells;\n\t\tvar counter = 0;\n\t\tvar string = '#ERROR';\n\t\tvar fname = /sum/i.test(value) ? 'sum': 'mean';\n\n\t\tvalue = value.replace(/(sum|mean|[\\(\\)]+)/ig,'').replace(' ','');\n\t\tcells = value.split(':');\n\t\tstartLetter = cells[0][0];\n\t\tendLetter = cells[1][0];\n\n\t\tif (startLetter === endLetter) {\n\t\t\tstartNum = parseInt(cells[0][1]);\n\t\t\tendNum = parseInt(cells[1][1]);\n\t\t\tif (endNum >= startNum) {\n\t\t\t\tstring = '';\n\t\t\t\tcounter = startNum;\n\t\t\t\twhile(startNum <= endNum) {\n\t\t\t\t\tstring += '+' + startLetter + startNum;\n\t\t\t\t\tstartNum++;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t\tstring = cleanupSumMean(string, fname, counter);\n\t\t\t}\n\t\t} else if (endLetter >= startLetter) {\n\t\t\tstartNum = cells[0][1];\n\t\t\tendNum = cells[1][1];\n\t\t\tif (endNum === startNum) {\n\t\t\t\tstring = '';\n\t\t\t\twhile(startLetter <= endLetter) {\n\t\t\t\t\tstring += '+' + startLetter + startNum;\n\t\t\t\t\tstartLetter++;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t\tstring = cleanupSumMean(string, fname, counter);\n\t\t\t}\n\t\t}\n\t\tconsole.log('>>>',string);\n\t\treturn string;\n\t}\n\n\tfunction parsePrimary() {\n\t\tvar result = {};\n\t\tvar value = peek();\n\t\tif (operatorRegex.test(value)) {\n\t\t\tresult = createToken(value, 'unary');\n\t\t\tresult.right = parseAdditive();\n\t\t} else if (numberRegex.test(value)) {\n\t\t\tresult = createToken(value, 'number');\n\t\t} else if (/^\\($/.test(value)) {\n\t\t\tresult = createToken(value, 'leftparen');\n\t\t\tresult.left = parseAdditive();\n\t\t\tvalue = peek();\n\t\t\tif (value === ')') {\n\t\t\t\tresult.right = createToken(value, 'rightparen');\n\t\t\t}\n\t\t} else if (cellRegex.test(value)) {\n\t\t\tresult = createToken(value, 'cellname');\n\t\t}\n\t\t/*\n\t\telse if (functionRegex.test(value)) {\n\t\t\tvar name = '';\n\t\t\tif (/sum/ig.test(value)) {\n\t\t\t\tname = 'sum';\n\t\t\t} else if (/^(avg|mean)/ig.test(value)) {\n\t\t\t\tname = \"mean\";\n\t\t\t}\n\n\t\t\tsumMean(name,value);\n\t\t\tresult = createToken(value, name);\n\t\t} */\n\t\telse {\n\t\t\tresult = createToken(value, '');\n\t\t}\n\t\t//console.log('valuing:', value, result);\n\t\treturn result;\n\t}\n\n\tfunction parseMultiplicative() {\n\t\tvar expression = parsePrimary();\n\t\tvar token = peek();\n\n\t\twhile (token === '*' || token === '/') {\n\t\t\ttoken = next();\n\t\t\texpression = {\n\t\t\t\ttoken: token,\n\t\t\t\ttype: 'operator',\n\t\t\t\tleft: expression,\n\t\t\t\tright: parsePrimary()\n\t\t\t};\n\t\t\ttoken = peek();\n\t\t}\n\t\treturn expression;\n\t}\n\n\tfunction parseAdditive() {\n\t\tvar expression = parseMultiplicative();\n\t\tvar token = peek();\n\n\t\twhile (token === '+' || token === '-') {\n\t\t\ttoken = next();\n\t\t\texpression = {\n\t\t\t\ttoken: token,\n\t\t\t\ttype: 'operator',\n\t\t\t\tleft: expression,\n\t\t\t\tright: parseMultiplicative()\n\t\t\t};\n\t\t\ttoken = peek();\n\t\t}\n\t\treturn expression;\n\t}\n\n\tfunction parse(value) {\n\t\tposition = 0;\n\t\tvalue = value.replace(functionRegex, sumMean); //expand functions\n\t\ttokens = tokenize(value);\n\t\treturn parseAdditive();\n\t}\n\n\treturn parse;\n})();\n"],"sourceRoot":"/source/"}