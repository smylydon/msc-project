{"version":3,"sources":["parser.js"],"names":["window","parser","tokenize","value","m","results","tokenRegEx","exec","push","peek","tokens","position","next","createToken","type","token","parsePrimary","result","operatorRegex","test","right","parseAdditive","numberRegex","left","cellRegex","parseMultiplicative","expression","nextChar","c","String","fromCharCode","charCodeAt","cleanupSumMean","string","fname","counter","replace","expandSumAndMean","cells","startLetter","endLetter","startNum","endNum","split","parseInt","console","log","setSpreadSheet","collection","spreadSheet","expandCells","label","cell","getCellById","formula","cellRegex2","parse","functionRegex"],"mappings":"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","file":"parser.js","sourcesContent":["window.parser = (function () {\n\tvar functionRegex = /(sum|avg|mean)\\(\\s*[a-z]([1-9]\\d+|[1-9])\\s*:\\s*[a-z]([1-9]\\d+|[1-9])\\s*\\)/ig;\n\tvar cellRegex = /^[A-Z]([1-9]\\d+|[1-9])$/i;\n\tvar cellRegex2 = /[A-Z]([1-9]\\d+|[1-9])/ig;\n\tvar operatorRegex = /[+\\-\\/\\*]/;\n\tvar numberRegex = /^\\d+(\\.\\d+)?$/;\n\tvar position = 0;\n\tvar tokens = [];\n\n\tfunction tokenize(value) {\n\t\tvar results = [];\n\t\tvar tokenRegEx = /([A-Z]([1-9]\\d+|[1-9])|\\d+(\\.\\d+)?|[+\\-\\/\\*]|\\(|\\))/ig;\n\n\t\tvar m;\n\t\twhile ((m = tokenRegEx.exec(value)) !== null) {\n\t\t\tresults.push(m[0]); //save token\n\t\t}\n\t\treturn results;\n\t}\n\n\tfunction peek() {\n\t\treturn tokens[position];\n\t}\n\n\tfunction next() {\n\t\tvar value = peek();\n\t\tposition++;\n\t\treturn value;\n\t}\n\n\tfunction createToken(value, type) {\n\t\tposition++;\n\t\treturn {\n\t\t\ttoken: value,\n\t\t\ttype: type\n\t\t};\n\t}\n\n\tfunction parsePrimary() {\n\t\tvar result = {};\n\t\tvar value = peek();\n\n\t\tif (operatorRegex.test(value)) {\n\t\t\tresult = createToken(value, 'unary');\n\t\t\tresult.right = parseAdditive();\n\t\t} else if (numberRegex.test(value)) {\n\t\t\tresult = createToken(value, 'number');\n\t\t} else if (/^\\($/.test(value)) {\n\t\t\tresult = createToken(value, 'leftparen');\n\t\t\tresult.left = parseAdditive();\n\t\t\tvalue = peek();\n\t\t\tif (value === ')') {\n\t\t\t\tresult.right = createToken(value, 'rightparen');\n\t\t\t}\n\t\t} else if (cellRegex.test(value)) {\n\t\t\tresult = createToken(value, 'cellname');\n\t\t} else {\n\t\t\tresult = createToken(value, '');\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tfunction parseMultiplicative() {\n\t\tvar expression = parsePrimary();\n\t\tvar token = peek();\n\n\t\twhile (token === '*' || token === '/') {\n\t\t\ttoken = next();\n\t\t\texpression = {\n\t\t\t\ttoken: token,\n\t\t\t\ttype: 'operator',\n\t\t\t\tleft: expression,\n\t\t\t\tright: parsePrimary()\n\t\t\t};\n\t\t\ttoken = peek();\n\t\t}\n\t\treturn expression;\n\t}\n\n\tfunction parseAdditive() {\n\t\tvar expression = parseMultiplicative();\n\t\tvar token = peek();\n\n\t\twhile (token === '+' || token === '-') {\n\t\t\ttoken = next();\n\t\t\texpression = {\n\t\t\t\ttoken: token,\n\t\t\t\ttype: 'operator',\n\t\t\t\tleft: expression,\n\t\t\t\tright: parseMultiplicative()\n\t\t\t};\n\t\t\ttoken = peek();\n\t\t}\n\t\treturn expression;\n\t}\n\n\tfunction nextChar(c) {\n\t\treturn String.fromCharCode(c.charCodeAt(0) + 1);\n\t}\n\n\tfunction cleanupSumMean(string, fname, counter) {\n\t\tstring = string.replace(/^\\+/, '');\n\t\tstring = '(' + string + ')';\n\t\tif (fname === 'mean') {\n\t\t\tstring = '(' + string + '/' + counter + ')';\n\t\t}\n\t\treturn string;\n\t}\n\n\t/*\n\t * expandSumAndMean\n\t *\n\t * This function expands sum and mean into a longform\n\t * equivalent. Example:\n\t *\n\t * mean(a1:a5) => (a1+a2+a3+a4+a5)/5\n\t *\n\t * param {String} text rep of function\n\t */\n\tfunction expandSumAndMean(value) {\n\t\tvar startLetter = '';\n\t\tvar endLetter = '';\n\t\tvar startNum = '';\n\t\tvar endNum = '';\n\t\tvar cells;\n\t\tvar counter = 0;\n\t\tvar string = '#ERROR';\n\t\tvar fname = /sum/i.test(value) ? 'sum' : 'mean';\n\n\t\tvalue = value.replace(/(sum|avg|mean|[\\(\\)]+)/ig, '')\n\t\t\t.replace(' ', '');\n\t\tcells = value.split(':');\n\t\tstartLetter = cells[0][0];\n\t\tendLetter = cells[1][0];\n\t\tstartNum = parseInt(cells[0][1]);\n\t\tendNum = parseInt(cells[1][1]);\n\n\t\tif (startLetter === endLetter) {\n\t\t\tif (endNum >= startNum) {\n\t\t\t\tstring = '';\n\t\t\t\twhile (startNum <= endNum) {\n\t\t\t\t\tstring += '+' + startLetter + startNum;\n\t\t\t\t\tstartNum++;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t\tstring = cleanupSumMean(string, fname, counter);\n\t\t\t}\n\t\t} else if (endLetter >= startLetter) {\n\t\t\tif (endNum === startNum) {\n\t\t\t\tstring = '';\n\t\t\t\twhile (startLetter <= endLetter) {\n\t\t\t\t\tstring += '+' + startLetter + startNum;\n\t\t\t\t\tstartLetter = nextChar(startLetter);\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t\tstring = cleanupSumMean(string, fname, counter);\n\t\t\t}\n\t\t}\n\t\tconsole.log('>>>', string);\n\t\treturn string;\n\t}\n\n\tvar spreadSheet;\n\n\tfunction setSpreadSheet(collection) {\n\t\tspreadSheet = collection;\n\t}\n\n\t/*\n\t * expandCells\n\t *\n\t * Recursively removes transitive relationships. If this is not done\n\t * it results in glitches.\n\t *\n\t * Example:\n\t * A1 = 1\n\t * B1 = A1+1\n\t * C1 = B1 + A1\n\t *   -> A1 + 1 + A1\n\t *\n\t * param {String} user input\n\t */\n\tfunction expandCells(label) {\n\t\tvar cell = spreadSheet.getCellById(label);\n\t\tvar formula = cell.formula;\n\t\tif (cellRegex2.test(formula)) {\n\t\t\tlabel = formula.replace(cellRegex2, expandCells);\n\t\t}\n\t\treturn label;\n\t}\n\n\tfunction parse(value) {\n\t\tvalue = value || '';\n\t\tposition = 0;\n\t\tvalue = value.replace(functionRegex, expandSumAndMean);\n\t\tvalue = value.replace(cellRegex2, expandCells);\n\t\ttokens = tokenize(value);\n\t\treturn parseAdditive();\n\t}\n\n\treturn {\n\t\tparse: parse,\n\t\tsetSpreadSheet: setSpreadSheet\n\t};\n})();\n"],"sourceRoot":"/source/"}