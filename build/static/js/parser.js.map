{"version":3,"sources":["parser.js"],"names":["window","parser","tokenize","value","m","results","tokenRegEx","exec","push","peek","tokens","position","next","createToken","type","token","parsePrimary","result","operatorRegex","test","right","parseAdditive","numberRegex","left","cellRegex","parseMultiplicative","expression","nextChar","c","String","fromCharCode","charCodeAt","cleanupSumMean","string","fname","counter","replace","expandSumAndMean","cells","startLetter","endLetter","startNum","endNum","split","parseInt","console","log","setSpreadSheet","collection","spreadSheet","expandCells","visitedCells","label","cell","getCellById","formula","cellRegex2","indexOf","visited","id","Array","prototype","apply","curry","matches","match","length","args","slice","call","arguments","fn","shift","concat","parse","functionRegex"],"mappings":"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","file":"parser.js","sourcesContent":["window.parser = (function () {\n\tvar functionRegex = /(sum|avg|mean)\\(\\s*[a-z]([1-9]\\d+|[1-9])\\s*:\\s*[a-z]([1-9]\\d+|[1-9])\\s*\\)/ig;\n\tvar cellRegex = /^[A-Z]([1-9]\\d+|[1-9])$/i;\n\tvar cellRegex2 = /[A-Z]([1-9]\\d+|[1-9])/ig;\n\tvar operatorRegex = /[+\\-\\/\\*\\^]/;\n\tvar numberRegex = /^\\d+(\\.\\d+)?$/;\n\tvar position = 0;\n\tvar tokens = [];\n\tvar tokenRegEx = /([A-Z]([1-9]\\d+|[1-9])|\\d+(\\.\\d+)?|[+\\-\\/\\*\\^]|\\(|\\))/ig;\n\n\tfunction tokenize(value) {\n\t\tvar results = [];\n\t\tvar m;\n\n\t\twhile ((m = tokenRegEx.exec(value)) !== null) {\n\t\t\tresults.push(m[0]); //save token\n\t\t}\n\t\treturn results;\n\t}\n\n\tfunction peek() {\n\t\treturn tokens[position];\n\t}\n\n\tfunction next() {\n\t\tvar value = peek();\n\t\tposition++;\n\t\treturn value;\n\t}\n\n\tfunction createToken(value, type) {\n\t\tposition++;\n\t\treturn {\n\t\t\ttoken: value,\n\t\t\ttype: type\n\t\t};\n\t}\n\n\tfunction parsePrimary() {\n\t\tvar result = {};\n\t\tvar value = peek();\n\n\t\tif (operatorRegex.test(value)) {\n\t\t\tresult = createToken(value, 'unary');\n\t\t\tresult.right = parseAdditive();\n\t\t} else if (numberRegex.test(value)) {\n\t\t\tresult = createToken(value, 'number');\n\t\t} else if (/^\\($/.test(value)) {\n\t\t\tresult = createToken(value, 'leftparen');\n\t\t\tresult.left = parseAdditive();\n\t\t\tvalue = peek();\n\t\t\tif (value === ')') {\n\t\t\t\tresult.right = createToken(value, 'rightparen');\n\t\t\t}\n\t\t} else if (cellRegex.test(value)) {\n\t\t\tresult = createToken(value, 'cellname');\n\t\t} else {\n\t\t\tresult = createToken(value, '');\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tfunction parseMultiplicative() {\n\t\tvar expression = parsePrimary();\n\t\tvar token = peek();\n\n\t\twhile (token === '*' || token === '/' || token === '^') {\n\t\t\ttoken = next();\n\t\t\texpression = {\n\t\t\t\ttoken: token,\n\t\t\t\ttype: 'operator',\n\t\t\t\tleft: expression,\n\t\t\t\tright: parsePrimary()\n\t\t\t};\n\t\t\ttoken = peek();\n\t\t}\n\t\treturn expression;\n\t}\n\n\tfunction parseAdditive() {\n\t\tvar expression = parseMultiplicative();\n\t\tvar token = peek();\n\n\t\twhile (token === '+' || token === '-') {\n\t\t\ttoken = next();\n\t\t\texpression = {\n\t\t\t\ttoken: token,\n\t\t\t\ttype: 'operator',\n\t\t\t\tleft: expression,\n\t\t\t\tright: parseMultiplicative()\n\t\t\t};\n\t\t\ttoken = peek();\n\t\t}\n\t\treturn expression;\n\t}\n\n\tfunction nextChar(c) {\n\t\treturn String.fromCharCode(c.charCodeAt(0) + 1);\n\t}\n\n\tfunction cleanupSumMean(string, fname, counter) {\n\t\tstring = string.replace(/^\\+/, '');\n\t\tstring = '(' + string + ')';\n\t\tif (fname === 'mean') {\n\t\t\tstring = '(' + string + '/' + counter + ')';\n\t\t}\n\t\treturn string;\n\t}\n\n\t/*\n\t * expandSumAndMean\n\t *\n\t * This function expands sum and mean into a longform\n\t * equivalent. Example:\n\t *\n\t * mean(a1:a5) => (a1+a2+a3+a4+a5)/5\n\t *\n\t * param {String} text rep of function\n\t */\n\tfunction expandSumAndMean(value) {\n\t\tvar startLetter = '';\n\t\tvar endLetter = '';\n\t\tvar startNum = '';\n\t\tvar endNum = '';\n\t\tvar cells;\n\t\tvar counter = 0;\n\t\tvar string = '#ERROR';\n\t\tvar fname = /sum/i.test(value) ? 'sum' : 'mean';\n\n\t\tvalue = value.replace(/(sum|avg|mean|[\\(\\)]+)/ig, '')\n\t\t\t.replace(' ', '');\n\t\tcells = value.split(':');\n\t\tstartLetter = cells[0][0];\n\t\tendLetter = cells[1][0];\n\t\tstartNum = parseInt(cells[0][1]);\n\t\tendNum = parseInt(cells[1][1]);\n\n\t\tif (startLetter === endLetter) {\n\t\t\tif (endNum >= startNum) {\n\t\t\t\tstring = '';\n\t\t\t\twhile (startNum <= endNum) {\n\t\t\t\t\tstring += '+' + startLetter + startNum;\n\t\t\t\t\tstartNum++;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t\tstring = cleanupSumMean(string, fname, counter);\n\t\t\t}\n\t\t} else if (endLetter >= startLetter) {\n\t\t\tif (endNum === startNum) {\n\t\t\t\tstring = '';\n\t\t\t\twhile (startLetter <= endLetter) {\n\t\t\t\t\tstring += '+' + startLetter + startNum;\n\t\t\t\t\tstartLetter = nextChar(startLetter);\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t\tstring = cleanupSumMean(string, fname, counter);\n\t\t\t}\n\t\t}\n\t\tconsole.log('>>>', string);\n\t\treturn string;\n\t}\n\n\tvar spreadSheet;\n\n\tfunction setSpreadSheet(collection) {\n\t\tspreadSheet = collection;\n\t}\n\n\t/*\n\t * expandCells\n\t *\n\t * Recursively removes transitive relationships. If this is not done\n\t * it results in glitches.\n\t *\n\t * Example:\n\t * A1 = 1\n\t * B1 = A1+1\n\t * C1 = B1 + A1\n\t *   -> A1 + 1 + A1\n\t *\n\t * Added code to check for circular dependencies.\n\t *\n\t * param {String} user input\n\t */\n\tfunction expandCells(visitedCells, label) {\n\t\tvar cell = spreadSheet.getCellById(label);\n\t\tvar formula = cell.formula;\n\n\t\tif (cellRegex2.test(formula)) {\n\t\t\tif (visitedCells.indexOf(label) < 0) {\n\t\t\t\tvar visited = [cell.id];\n\t\t\t\tArray.prototype.push.apply(visited, visitedCells);\n\t\t\t\tlabel = formula.replace(cellRegex2, curry(expandCells, visited));\n\t\t\t} else {\n\t\t\t\tconsole.log('#ERROR CYCULAR DEPENDENCY', label, visitedCells);\n\t\t\t\tlabel = '#ERROR CYCULAR DEPENDENCY';\n\t\t\t}\n\t\t}\n\t\tvar matches = label.match(tokenRegEx);\n\t\tif (matches.length > 1) {\n\t\t\tlabel = '(' + label + ')';\n\t\t}\n\n\t\treturn label;\n\t}\n\n\tfunction curry() {\n\t\tvar args = Array.prototype.slice.call(arguments),\n\t\t\tfn = args.shift();\n\t\treturn function () {\n\t\t\treturn fn.apply(fn, args.concat(Array.prototype.slice.call(arguments)));\n\t\t};\n\t}\n\n\tfunction parse(value, label) {\n\t\tvalue = value || '';\n\t\tposition = 0;\n\t\tvalue = value.replace(functionRegex, expandSumAndMean);\n\t\tvalue = value.replace(cellRegex2, curry(expandCells, [label]));\n\n\t\tif (/ERROR/ig.test(value)) {\n\t\t\tif (/CIRCULAR/ig.test(value)) {\n\t\t\t\tvalue = '#ERROR CYCULAR DEPENDENCY';\n\t\t\t} else {\n\t\t\t\tvalue = '#ERROR';\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.log('tokenize:', value);\n\t\t\ttokens = tokenize(value);\n\t\t\tvalue = parseAdditive();\n\t\t}\n\t\treturn value;\n\t}\n\n\treturn {\n\t\tparse: parse,\n\t\tsetSpreadSheet: setSpreadSheet\n\t};\n})();\n"],"sourceRoot":"/source/"}