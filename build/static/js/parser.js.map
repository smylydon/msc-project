{"version":3,"sources":["parser.js"],"names":["window","parser","tokenize","value","m","results","tokenRegEx","exec","push","peek","tokens","position","next","createToken","type","token","nextChar","c","String","fromCharCode","charCodeAt","cleanupSumMean","string","fname","counter","replace","sumMean","cells","startLetter","endLetter","startNum","endNum","test","split","parseInt","console","log","parsePrimary","result","operatorRegex","right","parseAdditive","numberRegex","left","cellRegex","parseMultiplicative","expression","parse","functionRegex"],"mappings":"AAAA,YAAAA,QAAOC,OAAU,WAQhB,QAASC,GAASC,GAKjB,IAJA,GAGIC,GAHAC,KACAC,EAAa,wDAGuB,QAAhCF,EAAIE,EAAWC,KAAKJ,KAC3BE,EAAQG,KAAKJ,EAAE,GAEhB,OAAOC,GAGR,QAASI,KACR,GAAIN,GAAQO,EAAOC,EACnB,OAAOR,GAGR,QAASS,KACR,GAAIT,GAAQM,GAEZ,OADAE,KACOR,EAGR,QAASU,GAAYV,EAAOW,GAE3B,MADAH,MAECI,MAAOZ,EACPW,KAAMA,GAIR,QAASE,GAASC,GACjB,MAAOC,QAAOC,aAAaF,EAAEG,WAAW,GAAK,GAG9C,QAASC,GAAeC,EAAQC,EAAOC,GAMtC,MALAF,GAASA,EAAOG,QAAQ,MAAO,IAC/BH,EAAS,IAAMA,EAAS,IACV,SAAVC,IACHD,EAAS,IAAMA,EAAS,IAAME,EAAU,KAElCF,EAaR,QAASI,GAAQvB,GAChB,GAIIwB,GAJAC,EAAc,GACdC,EAAY,GACZC,EAAW,GACXC,EAAS,GAETP,EAAU,EACVF,EAAS,SACTC,EAAQ,OAAOS,KAAK7B,GAAS,MAAQ,MAUzC,IARAA,EAAQA,EAAMsB,QAAQ,2BAA4B,IAChDA,QAAQ,IAAK,IACfE,EAAQxB,EAAM8B,MAAM,KACpBL,EAAcD,EAAM,GAAG,GACvBE,EAAYF,EAAM,GAAG,GACrBG,EAAWI,SAASP,EAAM,GAAG,IAC7BI,EAASG,SAASP,EAAM,GAAG,IAEvBC,IAAgBC,GACnB,GAAIE,GAAUD,EAAU,CAEvB,IADAR,EAAS,GACFQ,GAAYC,GAClBT,GAAU,IAAMM,EAAcE,EAC9BA,IACAN,GAEDF,GAASD,EAAeC,EAAQC,EAAOC,QAElC,IAAIK,GAAaD,GACnBG,IAAWD,EAAU,CAExB,IADAR,EAAS,GACFM,GAAeC,GACrBP,GAAU,IAAMM,EAAcE,EAC9BF,EAAcZ,EAASY,GACvBJ,GAEDF,GAASD,EAAeC,EAAQC,EAAOC,GAIzC,MADAW,SAAQC,IAAI,MAAOd,GACZA,EAGR,QAASe,KACR,GAAIC,MACAnC,EAAQM,GAgCZ,OA/BI8B,GAAcP,KAAK7B,IACtBmC,EAASzB,EAAYV,EAAO,SAC5BmC,EAAOE,MAAQC,KACLC,EAAYV,KAAK7B,GAC3BmC,EAASzB,EAAYV,EAAO,UAClB,OAAO6B,KAAK7B,IACtBmC,EAASzB,EAAYV,EAAO,aAC5BmC,EAAOK,KAAOF,IACdtC,EAAQM,IACM,MAAVN,IACHmC,EAAOE,MAAQ3B,EAAYV,EAAO,gBAGnCmC,EADUM,EAAUZ,KAAK7B,GAChBU,EAAYV,EAAO,YAenBU,EAAYV,EAAO,IAGtBmC,EAGR,QAASO,KAIR,IAHA,GAAIC,GAAaT,IACbtB,EAAQN,IAEK,MAAVM,GAA2B,MAAVA,GACvBA,EAAQH,IACRkC,GACC/B,MAAOA,EACPD,KAAM,WACN6B,KAAMG,EACNN,MAAOH,KAERtB,EAAQN,GAET,OAAOqC,GAGR,QAASL,KAIR,IAHA,GAAIK,GAAaD,IACb9B,EAAQN,IAEK,MAAVM,GAA2B,MAAVA,GACvBA,EAAQH,IACRkC,GACC/B,MAAOA,EACPD,KAAM,WACN6B,KAAMG,EACNN,MAAOK,KAER9B,EAAQN,GAET,OAAOqC,GAGR,QAASC,GAAM5C,GAId,MAHAQ,GAAW,EACXR,EAAQA,EAAMsB,QAAQuB,EAAetB,GACrChB,EAASR,EAASC,GACXsC,IAlLR,GAAIO,GAAgB,8EAChBJ,EAAY,2BACZL,EAAgB,YAChBG,EAAc,gBACd/B,EAAW,EACXD,IAgLJ,OAAOqC","file":"parser.js","sourcesContent":["window.parser = (function () {\n\tvar functionRegex = /(sum|avg|mean)\\(\\s*[a-z]([1-9]\\d+|[1-9])\\s*:\\s*[a-z]([1-9]\\d+|[1-9])\\s*\\)/ig;\n\tvar cellRegex = /^[A-Z]([1-9]\\d+|[1-9])$/i;\n\tvar operatorRegex = /[+\\-\\/\\*]/;\n\tvar numberRegex = /^\\d+(\\.\\d+)?$/;\n\tvar position = 0;\n\tvar tokens = [];\n\n\tfunction tokenize(value) {\n\t\tvar results = [];\n\t\tvar tokenRegEx = /([A-Z]([1-9]\\d+|[1-9])|\\d+(\\.\\d+)?|[+\\-\\/\\*]|\\(|\\))/ig;\n\n\t\tvar m;\n\t\twhile ((m = tokenRegEx.exec(value)) !== null) {\n\t\t\tresults.push(m[0]); //save token\n\t\t}\n\t\treturn results;\n\t}\n\n\tfunction peek() {\n\t\tvar value = tokens[position];\n\t\treturn value;\n\t}\n\n\tfunction next() {\n\t\tvar value = peek();\n\t\tposition++;\n\t\treturn value;\n\t}\n\n\tfunction createToken(value, type) {\n\t\tposition++;\n\t\treturn {\n\t\t\ttoken: value,\n\t\t\ttype: type\n\t\t};\n\t}\n\n\tfunction nextChar(c) {\n\t\treturn String.fromCharCode(c.charCodeAt(0) + 1);\n\t}\n\n\tfunction cleanupSumMean(string, fname, counter) {\n\t\tstring = string.replace(/^\\+/, '');\n\t\tstring = '(' + string + ')';\n\t\tif (fname === 'mean') {\n\t\t\tstring = '(' + string + '/' + counter + ')';\n\t\t}\n\t\treturn string;\n\t}\n\n\t/*\n\t * sumMean\n\t *\n\t * This function expands sum and mean into a longform\n\t * equivalent. Example:\n\t *\n\t * mean(a1:a5) => (a1+a2+a3+a4+a5)/5\n\t *\n\t * param {String} text rep of function\n\t */\n\tfunction sumMean(value) {\n\t\tvar startLetter = '';\n\t\tvar endLetter = '';\n\t\tvar startNum = '';\n\t\tvar endNum = '';\n\t\tvar cells;\n\t\tvar counter = 0;\n\t\tvar string = '#ERROR';\n\t\tvar fname = /sum/i.test(value) ? 'sum' : 'mean';\n\n\t\tvalue = value.replace(/(sum|avg|mean|[\\(\\)]+)/ig, '')\n\t\t\t.replace(' ', '');\n\t\tcells = value.split(':');\n\t\tstartLetter = cells[0][0];\n\t\tendLetter = cells[1][0];\n\t\tstartNum = parseInt(cells[0][1]);\n\t\tendNum = parseInt(cells[1][1]);\n\n\t\tif (startLetter === endLetter) {\n\t\t\tif (endNum >= startNum) {\n\t\t\t\tstring = '';\n\t\t\t\twhile (startNum <= endNum) {\n\t\t\t\t\tstring += '+' + startLetter + startNum;\n\t\t\t\t\tstartNum++;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t\tstring = cleanupSumMean(string, fname, counter);\n\t\t\t}\n\t\t} else if (endLetter >= startLetter) {\n\t\t\tif (endNum === startNum) {\n\t\t\t\tstring = '';\n\t\t\t\twhile (startLetter <= endLetter) {\n\t\t\t\t\tstring += '+' + startLetter + startNum;\n\t\t\t\t\tstartLetter = nextChar(startLetter);\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t\tstring = cleanupSumMean(string, fname, counter);\n\t\t\t}\n\t\t}\n\t\tconsole.log('>>>', string);\n\t\treturn string;\n\t}\n\n\tfunction parsePrimary() {\n\t\tvar result = {};\n\t\tvar value = peek();\n\t\tif (operatorRegex.test(value)) {\n\t\t\tresult = createToken(value, 'unary');\n\t\t\tresult.right = parseAdditive();\n\t\t} else if (numberRegex.test(value)) {\n\t\t\tresult = createToken(value, 'number');\n\t\t} else if (/^\\($/.test(value)) {\n\t\t\tresult = createToken(value, 'leftparen');\n\t\t\tresult.left = parseAdditive();\n\t\t\tvalue = peek();\n\t\t\tif (value === ')') {\n\t\t\t\tresult.right = createToken(value, 'rightparen');\n\t\t\t}\n\t\t} else if (cellRegex.test(value)) {\n\t\t\tresult = createToken(value, 'cellname');\n\t\t}\n\t\t/*\n\t\telse if (functionRegex.test(value)) {\n\t\t\tvar name = '';\n\t\t\tif (/sum/ig.test(value)) {\n\t\t\t\tname = 'sum';\n\t\t\t} else if (/^(avg|mean)/ig.test(value)) {\n\t\t\t\tname = \"mean\";\n\t\t\t}\n\n\t\t\tsumMean(name,value);\n\t\t\tresult = createToken(value, name);\n\t\t} */\n\t\telse {\n\t\t\tresult = createToken(value, '');\n\t\t}\n\t\t//console.log('valuing:', value, result);\n\t\treturn result;\n\t}\n\n\tfunction parseMultiplicative() {\n\t\tvar expression = parsePrimary();\n\t\tvar token = peek();\n\n\t\twhile (token === '*' || token === '/') {\n\t\t\ttoken = next();\n\t\t\texpression = {\n\t\t\t\ttoken: token,\n\t\t\t\ttype: 'operator',\n\t\t\t\tleft: expression,\n\t\t\t\tright: parsePrimary()\n\t\t\t};\n\t\t\ttoken = peek();\n\t\t}\n\t\treturn expression;\n\t}\n\n\tfunction parseAdditive() {\n\t\tvar expression = parseMultiplicative();\n\t\tvar token = peek();\n\n\t\twhile (token === '+' || token === '-') {\n\t\t\ttoken = next();\n\t\t\texpression = {\n\t\t\t\ttoken: token,\n\t\t\t\ttype: 'operator',\n\t\t\t\tleft: expression,\n\t\t\t\tright: parseMultiplicative()\n\t\t\t};\n\t\t\ttoken = peek();\n\t\t}\n\t\treturn expression;\n\t}\n\n\tfunction parse(value) {\n\t\tposition = 0;\n\t\tvalue = value.replace(functionRegex, sumMean); //expand sum and mean functions\n\t\ttokens = tokenize(value);\n\t\treturn parseAdditive();\n\t}\n\n\treturn parse;\n})();\n"],"sourceRoot":"/source/"}